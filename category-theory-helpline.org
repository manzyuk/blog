# -*- eval: (org2blog/wp-mode 1) -*-
#+DATE: [2012-12-02]
#+TITLE: Category Theory Helpline
#+POSTID: 1311

One of my colleagues, [[http://nattermorphisms.blogspot.com/][Ben Moseley]], has recently asked an interesting
category theoretic question.  I've decided to write up my answer in a
blog post.

* Preliminaries

This blog post is a literate Haskell program.  First, we are going to
enable a few language extensions and import a few modules:

#+begin_src literate-haskell
> {-# LANGUAGE FlexibleInstances     #-}
> {-# LANGUAGE MultiParamTypeClasses #-}
> {-# LANGUAGE TupleSections         #-}
> {-# LANGUAGE TypeOperators         #-}
> import Control.Arrow
> import Data.Traversable
> import Prelude hiding (sequence)
#+end_src

Next, we are going to recall the definitions of the fixed point of a
functor =f=, the free monad generated by =f=, and the cofree comonad
generated by =f=:

#+begin_src literate-haskell
> newtype Fix f = Fix { unFix :: f (Fix f) }
> data Free f a = Pure a | Free (f (Free f a))
> data Cofree f a = a :< f (Cofree f a)
#+end_src

All three definitions are fairly standard.  The last two can be found,
for example, in Edward Kmett's package [[http://hackage.haskell.org/package/free][free]].

=Fix f= is both an initial algebra and final coalgebra for =f=: the
=f=-algebra structure is given by =Fix :: f (Fix f) -> Fix f=, and the
=f=-coalgebra structure is given by =unFix :: Fix f -> f (Fix f)=.

The initiality means that for each =f=-algebra =alg :: f a -> a= there
exists a unique =f=-algebra morphism =cata alg :: Fix f -> a=, called
/catamorphism/.  =cata alg= being an =f=-algebra morphism means that
the following equation holds:

#+begin_example
cata alg . Fix == alg . fmap (cata alg)
#+end_example

from which we can read off the definition of =cata alg=:

#+begin_src literate-haskell
> cata :: Functor f => (f a -> a) -> Fix f -> a
> cata alg = alg . fmap (cata alg) . unFix
#+end_src

Similarly, the finality means that for each =f=-coalgebra =coalg :: a
-> f a= there exists a unique =f=-coalgebra morphism =ana coalg :: a
-> Fix f=, called /anamorphism/.  =ana coalg= being an =f=-coalgebra
morphism means that the following equation holds:

#+begin_example
unFix . ana coalg == fmap (ana coalg) . coalg
#+end_example

from which we can read off the definition of =ana coalg=:

#+begin_src literate-haskell
> ana :: Functor f => (a -> f a) -> a -> Fix f
> ana coalg = Fix . fmap (ana coalg) . coalg
#+end_src

The functions =cata= and =ana= are only two examples of the plethora
of recursion schemes associated with the type =Fix f=.  The types
=Free f a= and =Cofree f a= also have associated recursion schemes:

#+begin_src literate-haskell
> fold :: Functor f => (Either a (f b) -> b) -> Free f a -> b
> fold f m = f $ case m of
>   Pure x -> Left x
>   Free n -> Right $ fmap (fold f) n

> unfold :: Functor f => (b -> (a, f b)) -> b -> Cofree f a
> unfold f c = case f c of
>   (x, d) -> x :< fmap (unfold f) d
#+end_src

* The question

Ben wrote the following functions:

#+begin_src literate-haskell
> cofree2fix :: Functor f => Cofree f a -> Fix f
> cofree2fix = ana (\(_ :< fx) -> fx)

> fix2free :: Functor f => Fix f -> Free a
> fix2free = cata Free

> fix2cofree :: Functor f => (a, Fix f) -> Cofree f a
> fix2cofree (a, fx) = unfold (const a &&& unFix) fx

> free2fix :: Traversable f => Free f a -> Either a (Fix f)
> free2fix = fold (Left ||| (right Fix . sequence))
#+end_src

Here

#+begin_src haskell
(&&&) :: (a -> b) -> (a -> c) -> a -> (b, c)
#+end_src

and

#+begin_src haskell
(|||) :: (b -> d) -> (c -> d) -> Either b c -> d
#+end_src

are the standard mediating morphisms for products and sums.  They are
imported from =Control.Arrow=.  The function =sequence= is the
generalized version from =Data.Traversable=.

Ben then wrote:

#+begin_quote
I'm puzzled by the last one... It all typechecks, but there's a clear asymmetry between =fix2cofree= and =free2fix= which worries me...
#+end_quote

The rest of this blog post is an attempt to explain what is going on
here.

* It's fixed points all the way down

We first observe that =Free f a= is isomorphic to the fixed point of
the functor =Either a :. f=, and =Cofree f a= is isomorphic to the
fixed point of the functor =(,) a :. f=, where =:.= denotes functor
composition (thanks to [[http://ro-che.info/][Roman Cheplyaka]] for suggesting this notation):

#+begin_src literate-haskell
> newtype (f :. g) a = C { unC :: f (g a) }

> instance (Functor f, Functor g) => Functor (f :. g) where
>   fmap t (C x) = C $ fmap (fmap t) x
#+end_src

We can encode isomorphisms between types by means of a typeclass,
=Iso=:

#+begin_src literate-haskell
> class Iso a b where
>   iso :: a -> b
>   inv :: b -> a
#+end_src

The isomorphisms between =Free f a= and =Fix (Either a :. f)=, and
between =Cofree f a= and =Fix ((,) a :. f)= are then defined as
follows:

#+begin_src literate-haskell
> instance Functor f => Iso (Free f a) (Fix (Either a :. f)) where
>   iso = fold (Fix . C)
>   inv = cata (either Pure Free . unC)

> instance Functor f => Iso (Cofree f a) (Fix ((,) a :. f)) where
>   iso = ana (\(x :< fx) -> C (x, fx))
>   inv = unfold (unC . unFix)
#+end_src

Under this identification, the recursion schemes =fold= and =unfold=
identify with =cata= and =ana= respectively.

We shall show now that there is a principled, systematic way to derive
=cofree2fix=, =fix2free=, =fix2cofree=, and =free2fix= from the
universal properties of fixed points.

** =cofree2fix=

By the finality of =Fix f=, functions

#+begin_src haskell
Functor f => Fix ((,) a :. f) -> Fix f
#+end_src

are in bijection with functions

#+begin_src haskell
Functor f => Fix ((,) a :. f) -> f (Fix ((,) a :. f))
#+end_src

There is an obvious natural representative of the latter type, namely
the composite =snd . unC . unFix=, leading to the following
definition:

#+begin_src literate-haskell
> cofree2fix' :: Functor f => Fix ((,) a :. f) -> Fix f
> cofree2fix' = ana (snd . unC . unFix)
#+end_src

** =fix2free=

By the initiality of =Fix f=, functions

#+begin_src haskell
Functor f => Fix f -> Fix (Either a :. f)
#+end_src

are in bijection with functions

#+begin_src haskell
Functor f => f (Fix (Either a :. f)) -> Fix (Either a :. f)
#+end_src

There is an obvious natural representative of the latter type, namely
the composite =Fix . C . Right=, which corresponds to the constructor
=Free= under the isomorphism between =Free f a= and =Fix (Either
a :. f)=.  Therefore, we can define

#+begin_src literate-haskell
> fix2free' :: Functor f => Fix f -> Fix (Either a :. f)
> fix2free' = cata (Fix . C . Right)
#+end_src

** =fix2cofree=

By the finality of =Fix ((,) a :. f)=, functions

#+begin_src haskell
Functor f => (a, Fix f) -> Fix ((,) a :. f)
#+end_src

are in bijection with functions

#+begin_src haskell
Functor f => (a, Fix f) -> ((,) a :. f) (a, Fix f)
#+end_src

The type =((,) a :. f) (a, Fix f)= is isomorphic to =(a, f (a, Fix
f))= by means of the constructor =C=.  Therefore, we need to define a
function of type

#+begin_src haskell
(a, Fix f) -> (a, f (a, Fix f))
#+end_src

By the universal property of product, any such function is necessarily
of the form =u &&& v= for uniquely determined

#+begin_src haskell
u :: (a, Fix f) -> a
#+end_src

and

#+begin_src haskell
v :: (a, Fix f) -> f (a, Fix f)
#+end_src

There is an obvious candidate for =u=: the function =fst= (and, in
fact, because we are after a polymorphic =u=, this is the only choice
we have).  Is there also a natural choice of =v=?  The answer is yes,
and the fundamental reason for that is that Haskell functors are
/strong/.  That is, an arbitrary functor =f= admits the following
natural transformation, which in category theory is called the /right
tensorial strength/:

#+begin_src literate-haskell
> strength :: Functor f => (a, f b) -> f (a, b)
> strength (x, fy) = fmap (x,) fy
#+end_src

This allows us to define

#+begin_src literate-haskell
> fix2cofree' :: Functor f => (a, Fix f) -> Fix ((,) a :. f)
> fix2cofree' = ana (C . (fst &&& strength . second unFix))
#+end_src

** =free2fix=

By the initiality of =Fix (Either a :. f)=, functions

#+begin_src haskell
Functor f => Fix (Either a :. f) -> Either a (Fix f)
#+end_src

are in bijection with functions

#+begin_src haskell
Functor f => (Either a :. f) (Either a (Fix f)) -> Either a (Fix f)
#+end_src

The type =(Either a :. f) (Either a (Fix f))= is isomorphic to =Either
a (f (Either a (Fix f)))= by means of =C=, therefore we are after a
function of type

#+begin_src haskell
Either a (f (Either a (Fix f))) -> Either a (Fix f)
#+end_src

By the universal property of sum, any such function is necessarily of
the form =p ||| q= with uniquely determined

#+begin_src haskell
p :: a -> Either a (Fix f)
#+end_src

and

#+begin_src haskell
q :: f (Either a (Fix f)) -> Either a (Fix f)
#+end_src

We have an obvious candidate for =p=: the function =Left= (and because
=p= has to be polymorphic, this is the only choice we have).  By
analogy with the previous case, we might expect that there always
exists a natural transformation of type

#+begin_src haskell
Functor f => f (Either a b) -> Either a (f b)
#+end_src

Alas, this is not the case.  There is, however, a large class of
functors that do admit a natural transformation of this type:
=Traversable= functors, and the required function is =sequence=.

Therefore, for =Traversable= functors we can define

#+begin_src literate-haskell
> free2fix' :: Traversable f => Fix (Either a :. f) -> Either a (Fix f)
> free2fix' = cata ((Left ||| (right Fix . sequence)) . unC)
#+end_src

* Summary

The short answer to Ben's question is this: =fix2cofree= works for any
functor because all functors in Haskell are /strong/: for each functor
=f=, there is a natural transformation =strength :: Functor f => (a, f
b) -> f (a, b)=, called the right tensorial strength, subject to
coherence axioms.

The fundamental fact underlying the existence of =strength= is that,
categorically, every Haskell functor is /enriched/: its action on
morphisms is given not merely as a map from the /set/ of functions =a
-> b= to the set of functions =f a -> f b=, but as a morphism (in the
category =Hask=) from the internal object of morphisms from =a= to
=b=, the type =a -> b=, to the internal object of morphisms from =f a=
to =f b=, the type =f a -> f b=.  This morphism is =fmap=, of course.
There is a one-to-one correspondence between enrichments of a functor
$F$ from a cartesian closed category $\mathcal{C}$ to itself and right
tensorial strengths on $F$.  For more information on strong functors,
see this [[http://ncatlab.org/nlab/show/tensorial+strength][nLab]] web page, or refer to the original [[home.imf.au.dk/kock/SFMM.pdf][paper]] by Anders Kock.

On the other hand, not every Haskell functor =f= admits a dual natural
transformation =Functor f => f (Either a b) -> Either a (f b)=.
=Traversable= functors do, but the former condition is weaker, I
think.

*Update*: User sclv on reddit [[http://www.reddit.com/r/haskell/comments/145iu5/why_free2fix_needs_traversable_and_fix2cofree/c7a3aj8][suggested]] that (up to the order of
summands) the function =f (Either a b) -> Either a (f b)= is called
/costrength/ in Edward Kmett's [[http://comonad.com/reader/2008/deriving-strength-from-laziness/][post]].
